{"ast":null,"code":"(function () {\n  var debug = false;\n  var root = this;\n  var EXIF = function (obj) {\n    if (obj instanceof EXIF) return obj;\n    if (!(this instanceof EXIF)) return new EXIF(obj);\n    this.EXIFwrapped = obj;\n  };\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = EXIF;\n    }\n    exports.EXIF = EXIF;\n  } else {\n    root.EXIF = EXIF;\n  }\n  var ExifTags = EXIF.Tags = {\n    // version tags\n    0x9000: \"ExifVersion\",\n    // EXIF version\n    0xA000: \"FlashpixVersion\",\n    // Flashpix format version\n\n    // colorspace tags\n    0xA001: \"ColorSpace\",\n    // Color space information tag\n\n    // image configuration\n    0xA002: \"PixelXDimension\",\n    // Valid width of meaningful image\n    0xA003: \"PixelYDimension\",\n    // Valid height of meaningful image\n    0x9101: \"ComponentsConfiguration\",\n    // Information about channels\n    0x9102: \"CompressedBitsPerPixel\",\n    // Compressed bits per pixel\n\n    // user information\n    0x927C: \"MakerNote\",\n    // Any desired information written by the manufacturer\n    0x9286: \"UserComment\",\n    // Comments by user\n\n    // related file\n    0xA004: \"RelatedSoundFile\",\n    // Name of related sound file\n\n    // date and time\n    0x9003: \"DateTimeOriginal\",\n    // Date and time when the original image was generated\n    0x9004: \"DateTimeDigitized\",\n    // Date and time when the image was stored digitally\n    0x9290: \"SubsecTime\",\n    // Fractions of seconds for DateTime\n    0x9291: \"SubsecTimeOriginal\",\n    // Fractions of seconds for DateTimeOriginal\n    0x9292: \"SubsecTimeDigitized\",\n    // Fractions of seconds for DateTimeDigitized\n\n    // picture-taking conditions\n    0x829A: \"ExposureTime\",\n    // Exposure time (in seconds)\n    0x829D: \"FNumber\",\n    // F number\n    0x8822: \"ExposureProgram\",\n    // Exposure program\n    0x8824: \"SpectralSensitivity\",\n    // Spectral sensitivity\n    0x8827: \"ISOSpeedRatings\",\n    // ISO speed rating\n    0x8828: \"OECF\",\n    // Optoelectric conversion factor\n    0x9201: \"ShutterSpeedValue\",\n    // Shutter speed\n    0x9202: \"ApertureValue\",\n    // Lens aperture\n    0x9203: \"BrightnessValue\",\n    // Value of brightness\n    0x9204: \"ExposureBias\",\n    // Exposure bias\n    0x9205: \"MaxApertureValue\",\n    // Smallest F number of lens\n    0x9206: \"SubjectDistance\",\n    // Distance to subject in meters\n    0x9207: \"MeteringMode\",\n    // Metering mode\n    0x9208: \"LightSource\",\n    // Kind of light source\n    0x9209: \"Flash\",\n    // Flash status\n    0x9214: \"SubjectArea\",\n    // Location and area of main subject\n    0x920A: \"FocalLength\",\n    // Focal length of the lens in mm\n    0xA20B: \"FlashEnergy\",\n    // Strobe energy in BCPS\n    0xA20C: \"SpatialFrequencyResponse\",\n    //\n    0xA20E: \"FocalPlaneXResolution\",\n    // Number of pixels in width direction per FocalPlaneResolutionUnit\n    0xA20F: \"FocalPlaneYResolution\",\n    // Number of pixels in height direction per FocalPlaneResolutionUnit\n    0xA210: \"FocalPlaneResolutionUnit\",\n    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n    0xA214: \"SubjectLocation\",\n    // Location of subject in image\n    0xA215: \"ExposureIndex\",\n    // Exposure index selected on camera\n    0xA217: \"SensingMethod\",\n    // Image sensor type\n    0xA300: \"FileSource\",\n    // Image source (3 == DSC)\n    0xA301: \"SceneType\",\n    // Scene type (1 == directly photographed)\n    0xA302: \"CFAPattern\",\n    // Color filter array geometric pattern\n    0xA401: \"CustomRendered\",\n    // Special processing\n    0xA402: \"ExposureMode\",\n    // Exposure mode\n    0xA403: \"WhiteBalance\",\n    // 1 = auto white balance, 2 = manual\n    0xA404: \"DigitalZoomRation\",\n    // Digital zoom ratio\n    0xA405: \"FocalLengthIn35mmFilm\",\n    // Equivalent foacl length assuming 35mm film camera (in mm)\n    0xA406: \"SceneCaptureType\",\n    // Type of scene\n    0xA407: \"GainControl\",\n    // Degree of overall image gain adjustment\n    0xA408: \"Contrast\",\n    // Direction of contrast processing applied by camera\n    0xA409: \"Saturation\",\n    // Direction of saturation processing applied by camera\n    0xA40A: \"Sharpness\",\n    // Direction of sharpness processing applied by camera\n    0xA40B: \"DeviceSettingDescription\",\n    //\n    0xA40C: \"SubjectDistanceRange\",\n    // Distance to subject\n\n    // other tags\n    0xA005: \"InteroperabilityIFDPointer\",\n    0xA420: \"ImageUniqueID\" // Identifier assigned uniquely to each image\n  };\n  var TiffTags = EXIF.TiffTags = {\n    0x0100: \"ImageWidth\",\n    0x0101: \"ImageHeight\",\n    0x8769: \"ExifIFDPointer\",\n    0x8825: \"GPSInfoIFDPointer\",\n    0xA005: \"InteroperabilityIFDPointer\",\n    0x0102: \"BitsPerSample\",\n    0x0103: \"Compression\",\n    0x0106: \"PhotometricInterpretation\",\n    0x0112: \"Orientation\",\n    0x0115: \"SamplesPerPixel\",\n    0x011C: \"PlanarConfiguration\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0213: \"YCbCrPositioning\",\n    0x011A: \"XResolution\",\n    0x011B: \"YResolution\",\n    0x0128: \"ResolutionUnit\",\n    0x0111: \"StripOffsets\",\n    0x0116: \"RowsPerStrip\",\n    0x0117: \"StripByteCounts\",\n    0x0201: \"JPEGInterchangeFormat\",\n    0x0202: \"JPEGInterchangeFormatLength\",\n    0x012D: \"TransferFunction\",\n    0x013E: \"WhitePoint\",\n    0x013F: \"PrimaryChromaticities\",\n    0x0211: \"YCbCrCoefficients\",\n    0x0214: \"ReferenceBlackWhite\",\n    0x0132: \"DateTime\",\n    0x010E: \"ImageDescription\",\n    0x010F: \"Make\",\n    0x0110: \"Model\",\n    0x0131: \"Software\",\n    0x013B: \"Artist\",\n    0x8298: \"Copyright\"\n  };\n  var GPSTags = EXIF.GPSTags = {\n    0x0000: \"GPSVersionID\",\n    0x0001: \"GPSLatitudeRef\",\n    0x0002: \"GPSLatitude\",\n    0x0003: \"GPSLongitudeRef\",\n    0x0004: \"GPSLongitude\",\n    0x0005: \"GPSAltitudeRef\",\n    0x0006: \"GPSAltitude\",\n    0x0007: \"GPSTimeStamp\",\n    0x0008: \"GPSSatellites\",\n    0x0009: \"GPSStatus\",\n    0x000A: \"GPSMeasureMode\",\n    0x000B: \"GPSDOP\",\n    0x000C: \"GPSSpeedRef\",\n    0x000D: \"GPSSpeed\",\n    0x000E: \"GPSTrackRef\",\n    0x000F: \"GPSTrack\",\n    0x0010: \"GPSImgDirectionRef\",\n    0x0011: \"GPSImgDirection\",\n    0x0012: \"GPSMapDatum\",\n    0x0013: \"GPSDestLatitudeRef\",\n    0x0014: \"GPSDestLatitude\",\n    0x0015: \"GPSDestLongitudeRef\",\n    0x0016: \"GPSDestLongitude\",\n    0x0017: \"GPSDestBearingRef\",\n    0x0018: \"GPSDestBearing\",\n    0x0019: \"GPSDestDistanceRef\",\n    0x001A: \"GPSDestDistance\",\n    0x001B: \"GPSProcessingMethod\",\n    0x001C: \"GPSAreaInformation\",\n    0x001D: \"GPSDateStamp\",\n    0x001E: \"GPSDifferential\"\n  };\n\n  // EXIF 2.3 Spec\n  var IFD1Tags = EXIF.IFD1Tags = {\n    0x0100: \"ImageWidth\",\n    0x0101: \"ImageHeight\",\n    0x0102: \"BitsPerSample\",\n    0x0103: \"Compression\",\n    0x0106: \"PhotometricInterpretation\",\n    0x0111: \"StripOffsets\",\n    0x0112: \"Orientation\",\n    0x0115: \"SamplesPerPixel\",\n    0x0116: \"RowsPerStrip\",\n    0x0117: \"StripByteCounts\",\n    0x011A: \"XResolution\",\n    0x011B: \"YResolution\",\n    0x011C: \"PlanarConfiguration\",\n    0x0128: \"ResolutionUnit\",\n    0x0201: \"JpegIFOffset\",\n    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\n    0x0202: \"JpegIFByteCount\",\n    // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\n    0x0211: \"YCbCrCoefficients\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0213: \"YCbCrPositioning\",\n    0x0214: \"ReferenceBlackWhite\"\n  };\n  var StringValues = EXIF.StringValues = {\n    ExposureProgram: {\n      0: \"Not defined\",\n      1: \"Manual\",\n      2: \"Normal program\",\n      3: \"Aperture priority\",\n      4: \"Shutter priority\",\n      5: \"Creative program\",\n      6: \"Action program\",\n      7: \"Portrait mode\",\n      8: \"Landscape mode\"\n    },\n    MeteringMode: {\n      0: \"Unknown\",\n      1: \"Average\",\n      2: \"CenterWeightedAverage\",\n      3: \"Spot\",\n      4: \"MultiSpot\",\n      5: \"Pattern\",\n      6: \"Partial\",\n      255: \"Other\"\n    },\n    LightSource: {\n      0: \"Unknown\",\n      1: \"Daylight\",\n      2: \"Fluorescent\",\n      3: \"Tungsten (incandescent light)\",\n      4: \"Flash\",\n      9: \"Fine weather\",\n      10: \"Cloudy weather\",\n      11: \"Shade\",\n      12: \"Daylight fluorescent (D 5700 - 7100K)\",\n      13: \"Day white fluorescent (N 4600 - 5400K)\",\n      14: \"Cool white fluorescent (W 3900 - 4500K)\",\n      15: \"White fluorescent (WW 3200 - 3700K)\",\n      17: \"Standard light A\",\n      18: \"Standard light B\",\n      19: \"Standard light C\",\n      20: \"D55\",\n      21: \"D65\",\n      22: \"D75\",\n      23: \"D50\",\n      24: \"ISO studio tungsten\",\n      255: \"Other\"\n    },\n    Flash: {\n      0x0000: \"Flash did not fire\",\n      0x0001: \"Flash fired\",\n      0x0005: \"Strobe return light not detected\",\n      0x0007: \"Strobe return light detected\",\n      0x0009: \"Flash fired, compulsory flash mode\",\n      0x000D: \"Flash fired, compulsory flash mode, return light not detected\",\n      0x000F: \"Flash fired, compulsory flash mode, return light detected\",\n      0x0010: \"Flash did not fire, compulsory flash mode\",\n      0x0018: \"Flash did not fire, auto mode\",\n      0x0019: \"Flash fired, auto mode\",\n      0x001D: \"Flash fired, auto mode, return light not detected\",\n      0x001F: \"Flash fired, auto mode, return light detected\",\n      0x0020: \"No flash function\",\n      0x0041: \"Flash fired, red-eye reduction mode\",\n      0x0045: \"Flash fired, red-eye reduction mode, return light not detected\",\n      0x0047: \"Flash fired, red-eye reduction mode, return light detected\",\n      0x0049: \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n      0x004D: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n      0x004F: \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n      0x0059: \"Flash fired, auto mode, red-eye reduction mode\",\n      0x005D: \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n      0x005F: \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n    },\n    SensingMethod: {\n      1: \"Not defined\",\n      2: \"One-chip color area sensor\",\n      3: \"Two-chip color area sensor\",\n      4: \"Three-chip color area sensor\",\n      5: \"Color sequential area sensor\",\n      7: \"Trilinear sensor\",\n      8: \"Color sequential linear sensor\"\n    },\n    SceneCaptureType: {\n      0: \"Standard\",\n      1: \"Landscape\",\n      2: \"Portrait\",\n      3: \"Night scene\"\n    },\n    SceneType: {\n      1: \"Directly photographed\"\n    },\n    CustomRendered: {\n      0: \"Normal process\",\n      1: \"Custom process\"\n    },\n    WhiteBalance: {\n      0: \"Auto white balance\",\n      1: \"Manual white balance\"\n    },\n    GainControl: {\n      0: \"None\",\n      1: \"Low gain up\",\n      2: \"High gain up\",\n      3: \"Low gain down\",\n      4: \"High gain down\"\n    },\n    Contrast: {\n      0: \"Normal\",\n      1: \"Soft\",\n      2: \"Hard\"\n    },\n    Saturation: {\n      0: \"Normal\",\n      1: \"Low saturation\",\n      2: \"High saturation\"\n    },\n    Sharpness: {\n      0: \"Normal\",\n      1: \"Soft\",\n      2: \"Hard\"\n    },\n    SubjectDistanceRange: {\n      0: \"Unknown\",\n      1: \"Macro\",\n      2: \"Close view\",\n      3: \"Distant view\"\n    },\n    FileSource: {\n      3: \"DSC\"\n    },\n    Components: {\n      0: \"\",\n      1: \"Y\",\n      2: \"Cb\",\n      3: \"Cr\",\n      4: \"R\",\n      5: \"G\",\n      6: \"B\"\n    }\n  };\n  function addEvent(element, event, handler) {\n    if (element.addEventListener) {\n      element.addEventListener(event, handler, false);\n    } else if (element.attachEvent) {\n      element.attachEvent(\"on\" + event, handler);\n    }\n  }\n  function imageHasData(img) {\n    return !!img.exifdata;\n  }\n  function base64ToArrayBuffer(base64, contentType) {\n    contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n    base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n    var binary = atob(base64);\n    var len = binary.length;\n    var buffer = new ArrayBuffer(len);\n    var view = new Uint8Array(buffer);\n    for (var i = 0; i < len; i++) {\n      view[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n  }\n  function objectURLToBlob(url, callback) {\n    var http = new XMLHttpRequest();\n    http.open(\"GET\", url, true);\n    http.responseType = \"blob\";\n    http.onload = function (e) {\n      if (this.status == 200 || this.status === 0) {\n        callback(this.response);\n      }\n    };\n    http.send();\n  }\n  function getImageData(img, callback) {\n    function handleBinaryFile(binFile) {\n      var data = findEXIFinJPEG(binFile);\n      img.exifdata = data || {};\n      var iptcdata = findIPTCinJPEG(binFile);\n      img.iptcdata = iptcdata || {};\n      if (EXIF.isXmpEnabled) {\n        var xmpdata = findXMPinJPEG(binFile);\n        img.xmpdata = xmpdata || {};\n      }\n      if (callback) {\n        callback.call(img);\n      }\n    }\n    if (img.src) {\n      if (/^data\\:/i.test(img.src)) {\n        // Data URI\n        var arrayBuffer = base64ToArrayBuffer(img.src);\n        handleBinaryFile(arrayBuffer);\n      } else if (/^blob\\:/i.test(img.src)) {\n        // Object URL\n        var fileReader = new FileReader();\n        fileReader.onload = function (e) {\n          handleBinaryFile(e.target.result);\n        };\n        objectURLToBlob(img.src, function (blob) {\n          fileReader.readAsArrayBuffer(blob);\n        });\n      } else {\n        var http = new XMLHttpRequest();\n        http.onload = function () {\n          if (this.status == 200 || this.status === 0) {\n            handleBinaryFile(http.response);\n          } else {\n            throw \"Could not load image\";\n          }\n          http = null;\n        };\n        http.open(\"GET\", img.src, true);\n        http.responseType = \"arraybuffer\";\n        http.send(null);\n      }\n    } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\n      var fileReader = new FileReader();\n      fileReader.onload = function (e) {\n        if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n        handleBinaryFile(e.target.result);\n      };\n      fileReader.readAsArrayBuffer(img);\n    }\n  }\n  function findEXIFinJPEG(file) {\n    var dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n    if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n    var offset = 2,\n      length = file.byteLength,\n      marker;\n    while (offset < length) {\n      if (dataView.getUint8(offset) != 0xFF) {\n        if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n        return false; // not a valid marker, something is wrong\n      }\n      marker = dataView.getUint8(offset + 1);\n      if (debug) console.log(marker);\n\n      // we could implement handling for other markers here,\n      // but we're only looking for 0xFFE1 for EXIF data\n\n      if (marker == 225) {\n        if (debug) console.log(\"Found 0xFFE1 marker\");\n        return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n\n        // offset += 2 + file.getShortAt(offset+2, true);\n      } else {\n        offset += 2 + dataView.getUint16(offset + 2);\n      }\n    }\n  }\n  function findIPTCinJPEG(file) {\n    var dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n    if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n    var offset = 2,\n      length = file.byteLength;\n    var isFieldSegmentStart = function (dataView, offset) {\n      return dataView.getUint8(offset) === 0x38 && dataView.getUint8(offset + 1) === 0x42 && dataView.getUint8(offset + 2) === 0x49 && dataView.getUint8(offset + 3) === 0x4D && dataView.getUint8(offset + 4) === 0x04 && dataView.getUint8(offset + 5) === 0x04;\n    };\n    while (offset < length) {\n      if (isFieldSegmentStart(dataView, offset)) {\n        // Get the length of the name header (which is padded to an even number of bytes)\n        var nameHeaderLength = dataView.getUint8(offset + 7);\n        if (nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n        // Check for pre photoshop 6 format\n        if (nameHeaderLength === 0) {\n          // Always 4\n          nameHeaderLength = 4;\n        }\n        var startOffset = offset + 8 + nameHeaderLength;\n        var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n        return readIPTCData(file, startOffset, sectionLength);\n        break;\n      }\n\n      // Not the marker, continue searching\n      offset++;\n    }\n  }\n  var IptcFieldMap = {\n    0x78: 'caption',\n    0x6E: 'credit',\n    0x19: 'keywords',\n    0x37: 'dateCreated',\n    0x50: 'byline',\n    0x55: 'bylineTitle',\n    0x7A: 'captionWriter',\n    0x69: 'headline',\n    0x74: 'copyright',\n    0x0F: 'category'\n  };\n  function readIPTCData(file, startOffset, sectionLength) {\n    var dataView = new DataView(file);\n    var data = {};\n    var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n    var segmentStartPos = startOffset;\n    while (segmentStartPos < startOffset + sectionLength) {\n      if (dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos + 1) === 0x02) {\n        segmentType = dataView.getUint8(segmentStartPos + 2);\n        if (segmentType in IptcFieldMap) {\n          dataSize = dataView.getInt16(segmentStartPos + 3);\n          segmentSize = dataSize + 5;\n          fieldName = IptcFieldMap[segmentType];\n          fieldValue = getStringFromDB(dataView, segmentStartPos + 5, dataSize);\n          // Check if we already stored a value with this name\n          if (data.hasOwnProperty(fieldName)) {\n            // Value already stored with this name, create multivalue field\n            if (data[fieldName] instanceof Array) {\n              data[fieldName].push(fieldValue);\n            } else {\n              data[fieldName] = [data[fieldName], fieldValue];\n            }\n          } else {\n            data[fieldName] = fieldValue;\n          }\n        }\n      }\n      segmentStartPos++;\n    }\n    return data;\n  }\n  function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n    var entries = file.getUint16(dirStart, !bigEnd),\n      tags = {},\n      entryOffset,\n      tag,\n      i;\n    for (i = 0; i < entries; i++) {\n      entryOffset = dirStart + i * 12 + 2;\n      tag = strings[file.getUint16(entryOffset, !bigEnd)];\n      if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n      tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n    }\n    return tags;\n  }\n  function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n    var type = file.getUint16(entryOffset + 2, !bigEnd),\n      numValues = file.getUint32(entryOffset + 4, !bigEnd),\n      valueOffset = file.getUint32(entryOffset + 8, !bigEnd) + tiffStart,\n      offset,\n      vals,\n      val,\n      n,\n      numerator,\n      denominator;\n    switch (type) {\n      case 1: // byte, 8-bit unsigned int\n      case 7:\n        // undefined, 8-bit byte, value depending on field\n        if (numValues == 1) {\n          return file.getUint8(entryOffset + 8, !bigEnd);\n        } else {\n          offset = numValues > 4 ? valueOffset : entryOffset + 8;\n          vals = [];\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint8(offset + n);\n          }\n          return vals;\n        }\n      case 2:\n        // ascii, 8-bit byte\n        offset = numValues > 4 ? valueOffset : entryOffset + 8;\n        return getStringFromDB(file, offset, numValues - 1);\n      case 3:\n        // short, 16 bit int\n        if (numValues == 1) {\n          return file.getUint16(entryOffset + 8, !bigEnd);\n        } else {\n          offset = numValues > 2 ? valueOffset : entryOffset + 8;\n          vals = [];\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint16(offset + 2 * n, !bigEnd);\n          }\n          return vals;\n        }\n      case 4:\n        // long, 32 bit int\n        if (numValues == 1) {\n          return file.getUint32(entryOffset + 8, !bigEnd);\n        } else {\n          vals = [];\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getUint32(valueOffset + 4 * n, !bigEnd);\n          }\n          return vals;\n        }\n      case 5:\n        // rational = two long values, first is numerator, second is denominator\n        if (numValues == 1) {\n          numerator = file.getUint32(valueOffset, !bigEnd);\n          denominator = file.getUint32(valueOffset + 4, !bigEnd);\n          val = new Number(numerator / denominator);\n          val.numerator = numerator;\n          val.denominator = denominator;\n          return val;\n        } else {\n          vals = [];\n          for (n = 0; n < numValues; n++) {\n            numerator = file.getUint32(valueOffset + 8 * n, !bigEnd);\n            denominator = file.getUint32(valueOffset + 4 + 8 * n, !bigEnd);\n            vals[n] = new Number(numerator / denominator);\n            vals[n].numerator = numerator;\n            vals[n].denominator = denominator;\n          }\n          return vals;\n        }\n      case 9:\n        // slong, 32 bit signed int\n        if (numValues == 1) {\n          return file.getInt32(entryOffset + 8, !bigEnd);\n        } else {\n          vals = [];\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getInt32(valueOffset + 4 * n, !bigEnd);\n          }\n          return vals;\n        }\n      case 10:\n        // signed rational, two slongs, first is numerator, second is denominator\n        if (numValues == 1) {\n          return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset + 4, !bigEnd);\n        } else {\n          vals = [];\n          for (n = 0; n < numValues; n++) {\n            vals[n] = file.getInt32(valueOffset + 8 * n, !bigEnd) / file.getInt32(valueOffset + 4 + 8 * n, !bigEnd);\n          }\n          return vals;\n        }\n    }\n  }\n\n  /**\n  * Given an IFD (Image File Directory) start offset\n  * returns an offset to next IFD or 0 if it's the last IFD.\n  */\n  function getNextIFDOffset(dataView, dirStart, bigEnd) {\n    //the first 2bytes means the number of directory entries contains in this IFD\n    var entries = dataView.getUint16(dirStart, !bigEnd);\n\n    // After last directory entry, there is a 4bytes of data,\n    // it means an offset to next IFD.\n    // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n\n    return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\n  }\n  function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd) {\n    // get the IFD1 offset\n    var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart + firstIFDOffset, bigEnd);\n    if (!IFD1OffsetPointer) {\n      // console.log('******** IFD1Offset is empty, image thumb not found ********');\n      return {};\n    } else if (IFD1OffsetPointer > dataView.byteLength) {\n      // this should not happen\n      // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\n      return {};\n    }\n    // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\n\n    var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd);\n\n    // EXIF 2.3 specification for JPEG format thumbnail\n\n    // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n    // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n    // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n    // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n    // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n\n    if (thumbTags['Compression']) {\n      // console.log('Thumbnail image found!');\n\n      switch (thumbTags['Compression']) {\n        case 6:\n          // console.log('Thumbnail image format is JPEG');\n          if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\n            // extract the thumbnail\n            var tOffset = tiffStart + thumbTags.JpegIFOffset;\n            var tLength = thumbTags.JpegIFByteCount;\n            thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\n              type: 'image/jpeg'\n            });\n          }\n          break;\n        case 1:\n          console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\n          break;\n        default:\n          console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\n      }\n    } else if (thumbTags['PhotometricInterpretation'] == 2) {\n      console.log(\"Thumbnail image format is RGB, which is not implemented.\");\n    }\n    return thumbTags;\n  }\n  function getStringFromDB(buffer, start, length) {\n    var outstr = \"\";\n    for (n = start; n < start + length; n++) {\n      outstr += String.fromCharCode(buffer.getUint8(n));\n    }\n    return outstr;\n  }\n  function readEXIFData(file, start) {\n    if (getStringFromDB(file, start, 4) != \"Exif\") {\n      if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n      return false;\n    }\n    var bigEnd,\n      tags,\n      tag,\n      exifData,\n      gpsData,\n      tiffOffset = start + 6;\n\n    // test for TIFF validity and endianness\n    if (file.getUint16(tiffOffset) == 0x4949) {\n      bigEnd = false;\n    } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n      bigEnd = true;\n    } else {\n      if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n      return false;\n    }\n    if (file.getUint16(tiffOffset + 2, !bigEnd) != 0x002A) {\n      if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n      return false;\n    }\n    var firstIFDOffset = file.getUint32(tiffOffset + 4, !bigEnd);\n    if (firstIFDOffset < 0x00000008) {\n      if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset + 4, !bigEnd));\n      return false;\n    }\n    tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n    if (tags.ExifIFDPointer) {\n      exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n      for (tag in exifData) {\n        switch (tag) {\n          case \"LightSource\":\n          case \"Flash\":\n          case \"MeteringMode\":\n          case \"ExposureProgram\":\n          case \"SensingMethod\":\n          case \"SceneCaptureType\":\n          case \"SceneType\":\n          case \"CustomRendered\":\n          case \"WhiteBalance\":\n          case \"GainControl\":\n          case \"Contrast\":\n          case \"Saturation\":\n          case \"Sharpness\":\n          case \"SubjectDistanceRange\":\n          case \"FileSource\":\n            exifData[tag] = StringValues[tag][exifData[tag]];\n            break;\n          case \"ExifVersion\":\n          case \"FlashpixVersion\":\n            exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n            break;\n          case \"ComponentsConfiguration\":\n            exifData[tag] = StringValues.Components[exifData[tag][0]] + StringValues.Components[exifData[tag][1]] + StringValues.Components[exifData[tag][2]] + StringValues.Components[exifData[tag][3]];\n            break;\n        }\n        tags[tag] = exifData[tag];\n      }\n    }\n    if (tags.GPSInfoIFDPointer) {\n      gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n      for (tag in gpsData) {\n        switch (tag) {\n          case \"GPSVersionID\":\n            gpsData[tag] = gpsData[tag][0] + \".\" + gpsData[tag][1] + \".\" + gpsData[tag][2] + \".\" + gpsData[tag][3];\n            break;\n        }\n        tags[tag] = gpsData[tag];\n      }\n    }\n\n    // extract thumbnail\n    tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\n    return tags;\n  }\n  function findXMPinJPEG(file) {\n    if (!('DOMParser' in self)) {\n      // console.warn('XML parsing not supported without DOMParser');\n      return;\n    }\n    var dataView = new DataView(file);\n    if (debug) console.log(\"Got file of length \" + file.byteLength);\n    if (dataView.getUint8(0) != 0xFF || dataView.getUint8(1) != 0xD8) {\n      if (debug) console.log(\"Not a valid JPEG\");\n      return false; // not a valid jpeg\n    }\n    var offset = 2,\n      length = file.byteLength,\n      dom = new DOMParser();\n    while (offset < length - 4) {\n      if (getStringFromDB(dataView, offset, 4) == \"http\") {\n        var startOffset = offset - 1;\n        var sectionLength = dataView.getUint16(offset - 2) - 1;\n        var xmpString = getStringFromDB(dataView, startOffset, sectionLength);\n        var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\n        xmpString = xmpString.substring(xmpString.indexOf('<x:xmpmeta'), xmpEndIndex);\n        var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10;\n        //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n        //Without these namespaces, XML is thought to be invalid by parsers\n        xmpString = xmpString.slice(0, indexOfXmp) + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" ' + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ' + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" ' + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" ' + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" ' + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" ' + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" ' + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" ' + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" ' + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" ' + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" ' + xmpString.slice(indexOfXmp);\n        var domDocument = dom.parseFromString(xmpString, 'text/xml');\n        return xml2Object(domDocument);\n      } else {\n        offset++;\n      }\n    }\n  }\n  function xml2json(xml) {\n    var json = {};\n    if (xml.nodeType == 1) {\n      // element node\n      if (xml.attributes.length > 0) {\n        json['@attributes'] = {};\n        for (var j = 0; j < xml.attributes.length; j++) {\n          var attribute = xml.attributes.item(j);\n          json['@attributes'][attribute.nodeName] = attribute.nodeValue;\n        }\n      }\n    } else if (xml.nodeType == 3) {\n      // text node\n      return xml.nodeValue;\n    }\n\n    // deal with children\n    if (xml.hasChildNodes()) {\n      for (var i = 0; i < xml.childNodes.length; i++) {\n        var child = xml.childNodes.item(i);\n        var nodeName = child.nodeName;\n        if (json[nodeName] == null) {\n          json[nodeName] = xml2json(child);\n        } else {\n          if (json[nodeName].push == null) {\n            var old = json[nodeName];\n            json[nodeName] = [];\n            json[nodeName].push(old);\n          }\n          json[nodeName].push(xml2json(child));\n        }\n      }\n    }\n    return json;\n  }\n  function xml2Object(xml) {\n    try {\n      var obj = {};\n      if (xml.children.length > 0) {\n        for (var i = 0; i < xml.children.length; i++) {\n          var item = xml.children.item(i);\n          var attributes = item.attributes;\n          for (var idx in attributes) {\n            var itemAtt = attributes[idx];\n            var dataKey = itemAtt.nodeName;\n            var dataValue = itemAtt.nodeValue;\n            if (dataKey !== undefined) {\n              obj[dataKey] = dataValue;\n            }\n          }\n          var nodeName = item.nodeName;\n          if (typeof obj[nodeName] == \"undefined\") {\n            obj[nodeName] = xml2json(item);\n          } else {\n            if (typeof obj[nodeName].push == \"undefined\") {\n              var old = obj[nodeName];\n              obj[nodeName] = [];\n              obj[nodeName].push(old);\n            }\n            obj[nodeName].push(xml2json(item));\n          }\n        }\n      } else {\n        obj = xml.textContent;\n      }\n      return obj;\n    } catch (e) {\n      console.log(e.message);\n    }\n  }\n  EXIF.enableXmp = function () {\n    EXIF.isXmpEnabled = true;\n  };\n  EXIF.disableXmp = function () {\n    EXIF.isXmpEnabled = false;\n  };\n  EXIF.getData = function (img, callback) {\n    if ((self.Image && img instanceof self.Image || self.HTMLImageElement && img instanceof self.HTMLImageElement) && !img.complete) return false;\n    if (!imageHasData(img)) {\n      getImageData(img, callback);\n    } else {\n      if (callback) {\n        callback.call(img);\n      }\n    }\n    return true;\n  };\n  EXIF.getTag = function (img, tag) {\n    if (!imageHasData(img)) return;\n    return img.exifdata[tag];\n  };\n  EXIF.getIptcTag = function (img, tag) {\n    if (!imageHasData(img)) return;\n    return img.iptcdata[tag];\n  };\n  EXIF.getAllTags = function (img) {\n    if (!imageHasData(img)) return {};\n    var a,\n      data = img.exifdata,\n      tags = {};\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        tags[a] = data[a];\n      }\n    }\n    return tags;\n  };\n  EXIF.getAllIptcTags = function (img) {\n    if (!imageHasData(img)) return {};\n    var a,\n      data = img.iptcdata,\n      tags = {};\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        tags[a] = data[a];\n      }\n    }\n    return tags;\n  };\n  EXIF.pretty = function (img) {\n    if (!imageHasData(img)) return \"\";\n    var a,\n      data = img.exifdata,\n      strPretty = \"\";\n    for (a in data) {\n      if (data.hasOwnProperty(a)) {\n        if (typeof data[a] == \"object\") {\n          if (data[a] instanceof Number) {\n            strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n          } else {\n            strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n          }\n        } else {\n          strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n        }\n      }\n    }\n    return strPretty;\n  };\n  EXIF.readFromBinaryFile = function (file) {\n    return findEXIFinJPEG(file);\n  };\n  if (typeof define === 'function' && define.amd) {\n    define('exif-js', [], function () {\n      return EXIF;\n    });\n  }\n}).call(this);","map":{"version":3,"names":["debug","root","EXIF","obj","EXIFwrapped","exports","module","ExifTags","Tags","TiffTags","GPSTags","IFD1Tags","StringValues","ExposureProgram","MeteringMode","LightSource","Flash","SensingMethod","SceneCaptureType","SceneType","CustomRendered","WhiteBalance","GainControl","Contrast","Saturation","Sharpness","SubjectDistanceRange","FileSource","Components","addEvent","element","event","handler","addEventListener","attachEvent","imageHasData","img","exifdata","base64ToArrayBuffer","base64","contentType","match","replace","binary","atob","len","length","buffer","ArrayBuffer","view","Uint8Array","i","charCodeAt","objectURLToBlob","url","callback","http","XMLHttpRequest","open","responseType","onload","e","status","response","send","getImageData","handleBinaryFile","binFile","data","findEXIFinJPEG","iptcdata","findIPTCinJPEG","isXmpEnabled","xmpdata","findXMPinJPEG","call","src","test","arrayBuffer","fileReader","FileReader","target","result","blob","readAsArrayBuffer","self","Blob","File","console","log","byteLength","file","dataView","DataView","getUint8","offset","marker","readEXIFData","getUint16","isFieldSegmentStart","nameHeaderLength","startOffset","sectionLength","readIPTCData","IptcFieldMap","fieldValue","fieldName","dataSize","segmentType","segmentSize","segmentStartPos","getInt16","getStringFromDB","hasOwnProperty","Array","push","readTags","tiffStart","dirStart","strings","bigEnd","entries","tags","entryOffset","tag","readTagValue","type","numValues","getUint32","valueOffset","vals","val","n","numerator","denominator","Number","getInt32","getNextIFDOffset","readThumbnailImage","firstIFDOffset","IFD1OffsetPointer","thumbTags","JpegIFOffset","JpegIFByteCount","tOffset","tLength","start","outstr","String","fromCharCode","exifData","gpsData","tiffOffset","ExifIFDPointer","GPSInfoIFDPointer","dom","DOMParser","xmpString","xmpEndIndex","indexOf","substring","indexOfXmp","slice","domDocument","parseFromString","xml2Object","xml2json","xml","json","nodeType","attributes","j","attribute","item","nodeName","nodeValue","hasChildNodes","childNodes","child","old","children","idx","itemAtt","dataKey","dataValue","undefined","textContent","message","enableXmp","disableXmp","getData","Image","HTMLImageElement","complete","getTag","getIptcTag","getAllTags","a","getAllIptcTags","pretty","strPretty","readFromBinaryFile","define","amd"],"sources":["D:/SnapRoute/node_modules/exif-js/exif.js"],"sourcesContent":["(function() {\n\n    var debug = false;\n\n    var root = this;\n\n    var EXIF = function(obj) {\n        if (obj instanceof EXIF) return obj;\n        if (!(this instanceof EXIF)) return new EXIF(obj);\n        this.EXIFwrapped = obj;\n    };\n\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = EXIF;\n        }\n        exports.EXIF = EXIF;\n    } else {\n        root.EXIF = EXIF;\n    }\n\n    var ExifTags = EXIF.Tags = {\n\n        // version tags\n        0x9000 : \"ExifVersion\",             // EXIF version\n        0xA000 : \"FlashpixVersion\",         // Flashpix format version\n\n        // colorspace tags\n        0xA001 : \"ColorSpace\",              // Color space information tag\n\n        // image configuration\n        0xA002 : \"PixelXDimension\",         // Valid width of meaningful image\n        0xA003 : \"PixelYDimension\",         // Valid height of meaningful image\n        0x9101 : \"ComponentsConfiguration\", // Information about channels\n        0x9102 : \"CompressedBitsPerPixel\",  // Compressed bits per pixel\n\n        // user information\n        0x927C : \"MakerNote\",               // Any desired information written by the manufacturer\n        0x9286 : \"UserComment\",             // Comments by user\n\n        // related file\n        0xA004 : \"RelatedSoundFile\",        // Name of related sound file\n\n        // date and time\n        0x9003 : \"DateTimeOriginal\",        // Date and time when the original image was generated\n        0x9004 : \"DateTimeDigitized\",       // Date and time when the image was stored digitally\n        0x9290 : \"SubsecTime\",              // Fractions of seconds for DateTime\n        0x9291 : \"SubsecTimeOriginal\",      // Fractions of seconds for DateTimeOriginal\n        0x9292 : \"SubsecTimeDigitized\",     // Fractions of seconds for DateTimeDigitized\n\n        // picture-taking conditions\n        0x829A : \"ExposureTime\",            // Exposure time (in seconds)\n        0x829D : \"FNumber\",                 // F number\n        0x8822 : \"ExposureProgram\",         // Exposure program\n        0x8824 : \"SpectralSensitivity\",     // Spectral sensitivity\n        0x8827 : \"ISOSpeedRatings\",         // ISO speed rating\n        0x8828 : \"OECF\",                    // Optoelectric conversion factor\n        0x9201 : \"ShutterSpeedValue\",       // Shutter speed\n        0x9202 : \"ApertureValue\",           // Lens aperture\n        0x9203 : \"BrightnessValue\",         // Value of brightness\n        0x9204 : \"ExposureBias\",            // Exposure bias\n        0x9205 : \"MaxApertureValue\",        // Smallest F number of lens\n        0x9206 : \"SubjectDistance\",         // Distance to subject in meters\n        0x9207 : \"MeteringMode\",            // Metering mode\n        0x9208 : \"LightSource\",             // Kind of light source\n        0x9209 : \"Flash\",                   // Flash status\n        0x9214 : \"SubjectArea\",             // Location and area of main subject\n        0x920A : \"FocalLength\",             // Focal length of the lens in mm\n        0xA20B : \"FlashEnergy\",             // Strobe energy in BCPS\n        0xA20C : \"SpatialFrequencyResponse\",    //\n        0xA20E : \"FocalPlaneXResolution\",   // Number of pixels in width direction per FocalPlaneResolutionUnit\n        0xA20F : \"FocalPlaneYResolution\",   // Number of pixels in height direction per FocalPlaneResolutionUnit\n        0xA210 : \"FocalPlaneResolutionUnit\",    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n        0xA214 : \"SubjectLocation\",         // Location of subject in image\n        0xA215 : \"ExposureIndex\",           // Exposure index selected on camera\n        0xA217 : \"SensingMethod\",           // Image sensor type\n        0xA300 : \"FileSource\",              // Image source (3 == DSC)\n        0xA301 : \"SceneType\",               // Scene type (1 == directly photographed)\n        0xA302 : \"CFAPattern\",              // Color filter array geometric pattern\n        0xA401 : \"CustomRendered\",          // Special processing\n        0xA402 : \"ExposureMode\",            // Exposure mode\n        0xA403 : \"WhiteBalance\",            // 1 = auto white balance, 2 = manual\n        0xA404 : \"DigitalZoomRation\",       // Digital zoom ratio\n        0xA405 : \"FocalLengthIn35mmFilm\",   // Equivalent foacl length assuming 35mm film camera (in mm)\n        0xA406 : \"SceneCaptureType\",        // Type of scene\n        0xA407 : \"GainControl\",             // Degree of overall image gain adjustment\n        0xA408 : \"Contrast\",                // Direction of contrast processing applied by camera\n        0xA409 : \"Saturation\",              // Direction of saturation processing applied by camera\n        0xA40A : \"Sharpness\",               // Direction of sharpness processing applied by camera\n        0xA40B : \"DeviceSettingDescription\",    //\n        0xA40C : \"SubjectDistanceRange\",    // Distance to subject\n\n        // other tags\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0xA420 : \"ImageUniqueID\"            // Identifier assigned uniquely to each image\n    };\n\n    var TiffTags = EXIF.TiffTags = {\n        0x0100 : \"ImageWidth\",\n        0x0101 : \"ImageHeight\",\n        0x8769 : \"ExifIFDPointer\",\n        0x8825 : \"GPSInfoIFDPointer\",\n        0xA005 : \"InteroperabilityIFDPointer\",\n        0x0102 : \"BitsPerSample\",\n        0x0103 : \"Compression\",\n        0x0106 : \"PhotometricInterpretation\",\n        0x0112 : \"Orientation\",\n        0x0115 : \"SamplesPerPixel\",\n        0x011C : \"PlanarConfiguration\",\n        0x0212 : \"YCbCrSubSampling\",\n        0x0213 : \"YCbCrPositioning\",\n        0x011A : \"XResolution\",\n        0x011B : \"YResolution\",\n        0x0128 : \"ResolutionUnit\",\n        0x0111 : \"StripOffsets\",\n        0x0116 : \"RowsPerStrip\",\n        0x0117 : \"StripByteCounts\",\n        0x0201 : \"JPEGInterchangeFormat\",\n        0x0202 : \"JPEGInterchangeFormatLength\",\n        0x012D : \"TransferFunction\",\n        0x013E : \"WhitePoint\",\n        0x013F : \"PrimaryChromaticities\",\n        0x0211 : \"YCbCrCoefficients\",\n        0x0214 : \"ReferenceBlackWhite\",\n        0x0132 : \"DateTime\",\n        0x010E : \"ImageDescription\",\n        0x010F : \"Make\",\n        0x0110 : \"Model\",\n        0x0131 : \"Software\",\n        0x013B : \"Artist\",\n        0x8298 : \"Copyright\"\n    };\n\n    var GPSTags = EXIF.GPSTags = {\n        0x0000 : \"GPSVersionID\",\n        0x0001 : \"GPSLatitudeRef\",\n        0x0002 : \"GPSLatitude\",\n        0x0003 : \"GPSLongitudeRef\",\n        0x0004 : \"GPSLongitude\",\n        0x0005 : \"GPSAltitudeRef\",\n        0x0006 : \"GPSAltitude\",\n        0x0007 : \"GPSTimeStamp\",\n        0x0008 : \"GPSSatellites\",\n        0x0009 : \"GPSStatus\",\n        0x000A : \"GPSMeasureMode\",\n        0x000B : \"GPSDOP\",\n        0x000C : \"GPSSpeedRef\",\n        0x000D : \"GPSSpeed\",\n        0x000E : \"GPSTrackRef\",\n        0x000F : \"GPSTrack\",\n        0x0010 : \"GPSImgDirectionRef\",\n        0x0011 : \"GPSImgDirection\",\n        0x0012 : \"GPSMapDatum\",\n        0x0013 : \"GPSDestLatitudeRef\",\n        0x0014 : \"GPSDestLatitude\",\n        0x0015 : \"GPSDestLongitudeRef\",\n        0x0016 : \"GPSDestLongitude\",\n        0x0017 : \"GPSDestBearingRef\",\n        0x0018 : \"GPSDestBearing\",\n        0x0019 : \"GPSDestDistanceRef\",\n        0x001A : \"GPSDestDistance\",\n        0x001B : \"GPSProcessingMethod\",\n        0x001C : \"GPSAreaInformation\",\n        0x001D : \"GPSDateStamp\",\n        0x001E : \"GPSDifferential\"\n    };\n\n     // EXIF 2.3 Spec\n    var IFD1Tags = EXIF.IFD1Tags = {\n        0x0100: \"ImageWidth\",\n        0x0101: \"ImageHeight\",\n        0x0102: \"BitsPerSample\",\n        0x0103: \"Compression\",\n        0x0106: \"PhotometricInterpretation\",\n        0x0111: \"StripOffsets\",\n        0x0112: \"Orientation\",\n        0x0115: \"SamplesPerPixel\",\n        0x0116: \"RowsPerStrip\",\n        0x0117: \"StripByteCounts\",\n        0x011A: \"XResolution\",\n        0x011B: \"YResolution\",\n        0x011C: \"PlanarConfiguration\",\n        0x0128: \"ResolutionUnit\",\n        0x0201: \"JpegIFOffset\",    // When image format is JPEG, this value show offset to JPEG data stored.(aka \"ThumbnailOffset\" or \"JPEGInterchangeFormat\")\n        0x0202: \"JpegIFByteCount\", // When image format is JPEG, this value shows data size of JPEG image (aka \"ThumbnailLength\" or \"JPEGInterchangeFormatLength\")\n        0x0211: \"YCbCrCoefficients\",\n        0x0212: \"YCbCrSubSampling\",\n        0x0213: \"YCbCrPositioning\",\n        0x0214: \"ReferenceBlackWhite\"\n    };\n\n    var StringValues = EXIF.StringValues = {\n        ExposureProgram : {\n            0 : \"Not defined\",\n            1 : \"Manual\",\n            2 : \"Normal program\",\n            3 : \"Aperture priority\",\n            4 : \"Shutter priority\",\n            5 : \"Creative program\",\n            6 : \"Action program\",\n            7 : \"Portrait mode\",\n            8 : \"Landscape mode\"\n        },\n        MeteringMode : {\n            0 : \"Unknown\",\n            1 : \"Average\",\n            2 : \"CenterWeightedAverage\",\n            3 : \"Spot\",\n            4 : \"MultiSpot\",\n            5 : \"Pattern\",\n            6 : \"Partial\",\n            255 : \"Other\"\n        },\n        LightSource : {\n            0 : \"Unknown\",\n            1 : \"Daylight\",\n            2 : \"Fluorescent\",\n            3 : \"Tungsten (incandescent light)\",\n            4 : \"Flash\",\n            9 : \"Fine weather\",\n            10 : \"Cloudy weather\",\n            11 : \"Shade\",\n            12 : \"Daylight fluorescent (D 5700 - 7100K)\",\n            13 : \"Day white fluorescent (N 4600 - 5400K)\",\n            14 : \"Cool white fluorescent (W 3900 - 4500K)\",\n            15 : \"White fluorescent (WW 3200 - 3700K)\",\n            17 : \"Standard light A\",\n            18 : \"Standard light B\",\n            19 : \"Standard light C\",\n            20 : \"D55\",\n            21 : \"D65\",\n            22 : \"D75\",\n            23 : \"D50\",\n            24 : \"ISO studio tungsten\",\n            255 : \"Other\"\n        },\n        Flash : {\n            0x0000 : \"Flash did not fire\",\n            0x0001 : \"Flash fired\",\n            0x0005 : \"Strobe return light not detected\",\n            0x0007 : \"Strobe return light detected\",\n            0x0009 : \"Flash fired, compulsory flash mode\",\n            0x000D : \"Flash fired, compulsory flash mode, return light not detected\",\n            0x000F : \"Flash fired, compulsory flash mode, return light detected\",\n            0x0010 : \"Flash did not fire, compulsory flash mode\",\n            0x0018 : \"Flash did not fire, auto mode\",\n            0x0019 : \"Flash fired, auto mode\",\n            0x001D : \"Flash fired, auto mode, return light not detected\",\n            0x001F : \"Flash fired, auto mode, return light detected\",\n            0x0020 : \"No flash function\",\n            0x0041 : \"Flash fired, red-eye reduction mode\",\n            0x0045 : \"Flash fired, red-eye reduction mode, return light not detected\",\n            0x0047 : \"Flash fired, red-eye reduction mode, return light detected\",\n            0x0049 : \"Flash fired, compulsory flash mode, red-eye reduction mode\",\n            0x004D : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected\",\n            0x004F : \"Flash fired, compulsory flash mode, red-eye reduction mode, return light detected\",\n            0x0059 : \"Flash fired, auto mode, red-eye reduction mode\",\n            0x005D : \"Flash fired, auto mode, return light not detected, red-eye reduction mode\",\n            0x005F : \"Flash fired, auto mode, return light detected, red-eye reduction mode\"\n        },\n        SensingMethod : {\n            1 : \"Not defined\",\n            2 : \"One-chip color area sensor\",\n            3 : \"Two-chip color area sensor\",\n            4 : \"Three-chip color area sensor\",\n            5 : \"Color sequential area sensor\",\n            7 : \"Trilinear sensor\",\n            8 : \"Color sequential linear sensor\"\n        },\n        SceneCaptureType : {\n            0 : \"Standard\",\n            1 : \"Landscape\",\n            2 : \"Portrait\",\n            3 : \"Night scene\"\n        },\n        SceneType : {\n            1 : \"Directly photographed\"\n        },\n        CustomRendered : {\n            0 : \"Normal process\",\n            1 : \"Custom process\"\n        },\n        WhiteBalance : {\n            0 : \"Auto white balance\",\n            1 : \"Manual white balance\"\n        },\n        GainControl : {\n            0 : \"None\",\n            1 : \"Low gain up\",\n            2 : \"High gain up\",\n            3 : \"Low gain down\",\n            4 : \"High gain down\"\n        },\n        Contrast : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        Saturation : {\n            0 : \"Normal\",\n            1 : \"Low saturation\",\n            2 : \"High saturation\"\n        },\n        Sharpness : {\n            0 : \"Normal\",\n            1 : \"Soft\",\n            2 : \"Hard\"\n        },\n        SubjectDistanceRange : {\n            0 : \"Unknown\",\n            1 : \"Macro\",\n            2 : \"Close view\",\n            3 : \"Distant view\"\n        },\n        FileSource : {\n            3 : \"DSC\"\n        },\n\n        Components : {\n            0 : \"\",\n            1 : \"Y\",\n            2 : \"Cb\",\n            3 : \"Cr\",\n            4 : \"R\",\n            5 : \"G\",\n            6 : \"B\"\n        }\n    };\n\n    function addEvent(element, event, handler) {\n        if (element.addEventListener) {\n            element.addEventListener(event, handler, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + event, handler);\n        }\n    }\n\n    function imageHasData(img) {\n        return !!(img.exifdata);\n    }\n\n\n    function base64ToArrayBuffer(base64, contentType) {\n        contentType = contentType || base64.match(/^data\\:([^\\;]+)\\;base64,/mi)[1] || ''; // e.g. 'data:image/jpeg;base64,...' => 'image/jpeg'\n        base64 = base64.replace(/^data\\:([^\\;]+)\\;base64,/gmi, '');\n        var binary = atob(base64);\n        var len = binary.length;\n        var buffer = new ArrayBuffer(len);\n        var view = new Uint8Array(buffer);\n        for (var i = 0; i < len; i++) {\n            view[i] = binary.charCodeAt(i);\n        }\n        return buffer;\n    }\n\n    function objectURLToBlob(url, callback) {\n        var http = new XMLHttpRequest();\n        http.open(\"GET\", url, true);\n        http.responseType = \"blob\";\n        http.onload = function(e) {\n            if (this.status == 200 || this.status === 0) {\n                callback(this.response);\n            }\n        };\n        http.send();\n    }\n\n    function getImageData(img, callback) {\n        function handleBinaryFile(binFile) {\n            var data = findEXIFinJPEG(binFile);\n            img.exifdata = data || {};\n            var iptcdata = findIPTCinJPEG(binFile);\n            img.iptcdata = iptcdata || {};\n            if (EXIF.isXmpEnabled) {\n               var xmpdata= findXMPinJPEG(binFile);\n               img.xmpdata = xmpdata || {};               \n            }\n            if (callback) {\n                callback.call(img);\n            }\n        }\n\n        if (img.src) {\n            if (/^data\\:/i.test(img.src)) { // Data URI\n                var arrayBuffer = base64ToArrayBuffer(img.src);\n                handleBinaryFile(arrayBuffer);\n\n            } else if (/^blob\\:/i.test(img.src)) { // Object URL\n                var fileReader = new FileReader();\n                fileReader.onload = function(e) {\n                    handleBinaryFile(e.target.result);\n                };\n                objectURLToBlob(img.src, function (blob) {\n                    fileReader.readAsArrayBuffer(blob);\n                });\n            } else {\n                var http = new XMLHttpRequest();\n                http.onload = function() {\n                    if (this.status == 200 || this.status === 0) {\n                        handleBinaryFile(http.response);\n                    } else {\n                        throw \"Could not load image\";\n                    }\n                    http = null;\n                };\n                http.open(\"GET\", img.src, true);\n                http.responseType = \"arraybuffer\";\n                http.send(null);\n            }\n        } else if (self.FileReader && (img instanceof self.Blob || img instanceof self.File)) {\n            var fileReader = new FileReader();\n            fileReader.onload = function(e) {\n                if (debug) console.log(\"Got file of length \" + e.target.result.byteLength);\n                handleBinaryFile(e.target.result);\n            };\n\n            fileReader.readAsArrayBuffer(img);\n        }\n    }\n\n    function findEXIFinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength,\n            marker;\n\n        while (offset < length) {\n            if (dataView.getUint8(offset) != 0xFF) {\n                if (debug) console.log(\"Not a valid marker at offset \" + offset + \", found: \" + dataView.getUint8(offset));\n                return false; // not a valid marker, something is wrong\n            }\n\n            marker = dataView.getUint8(offset + 1);\n            if (debug) console.log(marker);\n\n            // we could implement handling for other markers here,\n            // but we're only looking for 0xFFE1 for EXIF data\n\n            if (marker == 225) {\n                if (debug) console.log(\"Found 0xFFE1 marker\");\n\n                return readEXIFData(dataView, offset + 4, dataView.getUint16(offset + 2) - 2);\n\n                // offset += 2 + file.getShortAt(offset+2, true);\n\n            } else {\n                offset += 2 + dataView.getUint16(offset+2);\n            }\n\n        }\n\n    }\n\n    function findIPTCinJPEG(file) {\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n            if (debug) console.log(\"Not a valid JPEG\");\n            return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength;\n\n\n        var isFieldSegmentStart = function(dataView, offset){\n            return (\n                dataView.getUint8(offset) === 0x38 &&\n                dataView.getUint8(offset+1) === 0x42 &&\n                dataView.getUint8(offset+2) === 0x49 &&\n                dataView.getUint8(offset+3) === 0x4D &&\n                dataView.getUint8(offset+4) === 0x04 &&\n                dataView.getUint8(offset+5) === 0x04\n            );\n        };\n\n        while (offset < length) {\n\n            if ( isFieldSegmentStart(dataView, offset )){\n\n                // Get the length of the name header (which is padded to an even number of bytes)\n                var nameHeaderLength = dataView.getUint8(offset+7);\n                if(nameHeaderLength % 2 !== 0) nameHeaderLength += 1;\n                // Check for pre photoshop 6 format\n                if(nameHeaderLength === 0) {\n                    // Always 4\n                    nameHeaderLength = 4;\n                }\n\n                var startOffset = offset + 8 + nameHeaderLength;\n                var sectionLength = dataView.getUint16(offset + 6 + nameHeaderLength);\n\n                return readIPTCData(file, startOffset, sectionLength);\n\n                break;\n\n            }\n\n\n            // Not the marker, continue searching\n            offset++;\n\n        }\n\n    }\n    var IptcFieldMap = {\n        0x78 : 'caption',\n        0x6E : 'credit',\n        0x19 : 'keywords',\n        0x37 : 'dateCreated',\n        0x50 : 'byline',\n        0x55 : 'bylineTitle',\n        0x7A : 'captionWriter',\n        0x69 : 'headline',\n        0x74 : 'copyright',\n        0x0F : 'category'\n    };\n    function readIPTCData(file, startOffset, sectionLength){\n        var dataView = new DataView(file);\n        var data = {};\n        var fieldValue, fieldName, dataSize, segmentType, segmentSize;\n        var segmentStartPos = startOffset;\n        while(segmentStartPos < startOffset+sectionLength) {\n            if(dataView.getUint8(segmentStartPos) === 0x1C && dataView.getUint8(segmentStartPos+1) === 0x02){\n                segmentType = dataView.getUint8(segmentStartPos+2);\n                if(segmentType in IptcFieldMap) {\n                    dataSize = dataView.getInt16(segmentStartPos+3);\n                    segmentSize = dataSize + 5;\n                    fieldName = IptcFieldMap[segmentType];\n                    fieldValue = getStringFromDB(dataView, segmentStartPos+5, dataSize);\n                    // Check if we already stored a value with this name\n                    if(data.hasOwnProperty(fieldName)) {\n                        // Value already stored with this name, create multivalue field\n                        if(data[fieldName] instanceof Array) {\n                            data[fieldName].push(fieldValue);\n                        }\n                        else {\n                            data[fieldName] = [data[fieldName], fieldValue];\n                        }\n                    }\n                    else {\n                        data[fieldName] = fieldValue;\n                    }\n                }\n\n            }\n            segmentStartPos++;\n        }\n        return data;\n    }\n\n\n\n    function readTags(file, tiffStart, dirStart, strings, bigEnd) {\n        var entries = file.getUint16(dirStart, !bigEnd),\n            tags = {},\n            entryOffset, tag,\n            i;\n\n        for (i=0;i<entries;i++) {\n            entryOffset = dirStart + i*12 + 2;\n            tag = strings[file.getUint16(entryOffset, !bigEnd)];\n            if (!tag && debug) console.log(\"Unknown tag: \" + file.getUint16(entryOffset, !bigEnd));\n            tags[tag] = readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd);\n        }\n        return tags;\n    }\n\n\n    function readTagValue(file, entryOffset, tiffStart, dirStart, bigEnd) {\n        var type = file.getUint16(entryOffset+2, !bigEnd),\n            numValues = file.getUint32(entryOffset+4, !bigEnd),\n            valueOffset = file.getUint32(entryOffset+8, !bigEnd) + tiffStart,\n            offset,\n            vals, val, n,\n            numerator, denominator;\n\n        switch (type) {\n            case 1: // byte, 8-bit unsigned int\n            case 7: // undefined, 8-bit byte, value depending on field\n                if (numValues == 1) {\n                    return file.getUint8(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint8(offset + n);\n                    }\n                    return vals;\n                }\n\n            case 2: // ascii, 8-bit byte\n                offset = numValues > 4 ? valueOffset : (entryOffset + 8);\n                return getStringFromDB(file, offset, numValues-1);\n\n            case 3: // short, 16 bit int\n                if (numValues == 1) {\n                    return file.getUint16(entryOffset + 8, !bigEnd);\n                } else {\n                    offset = numValues > 2 ? valueOffset : (entryOffset + 8);\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint16(offset + 2*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 4: // long, 32 bit int\n                if (numValues == 1) {\n                    return file.getUint32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getUint32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 5:    // rational = two long values, first is numerator, second is denominator\n                if (numValues == 1) {\n                    numerator = file.getUint32(valueOffset, !bigEnd);\n                    denominator = file.getUint32(valueOffset+4, !bigEnd);\n                    val = new Number(numerator / denominator);\n                    val.numerator = numerator;\n                    val.denominator = denominator;\n                    return val;\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        numerator = file.getUint32(valueOffset + 8*n, !bigEnd);\n                        denominator = file.getUint32(valueOffset+4 + 8*n, !bigEnd);\n                        vals[n] = new Number(numerator / denominator);\n                        vals[n].numerator = numerator;\n                        vals[n].denominator = denominator;\n                    }\n                    return vals;\n                }\n\n            case 9: // slong, 32 bit signed int\n                if (numValues == 1) {\n                    return file.getInt32(entryOffset + 8, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 4*n, !bigEnd);\n                    }\n                    return vals;\n                }\n\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\n                if (numValues == 1) {\n                    return file.getInt32(valueOffset, !bigEnd) / file.getInt32(valueOffset+4, !bigEnd);\n                } else {\n                    vals = [];\n                    for (n=0;n<numValues;n++) {\n                        vals[n] = file.getInt32(valueOffset + 8*n, !bigEnd) / file.getInt32(valueOffset+4 + 8*n, !bigEnd);\n                    }\n                    return vals;\n                }\n        }\n    }\n\n    /**\n    * Given an IFD (Image File Directory) start offset\n    * returns an offset to next IFD or 0 if it's the last IFD.\n    */\n    function getNextIFDOffset(dataView, dirStart, bigEnd){\n        //the first 2bytes means the number of directory entries contains in this IFD\n        var entries = dataView.getUint16(dirStart, !bigEnd);\n\n        // After last directory entry, there is a 4bytes of data,\n        // it means an offset to next IFD.\n        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n\n        return dataView.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long\n    }\n\n    function readThumbnailImage(dataView, tiffStart, firstIFDOffset, bigEnd){\n        // get the IFD1 offset\n        var IFD1OffsetPointer = getNextIFDOffset(dataView, tiffStart+firstIFDOffset, bigEnd);\n\n        if (!IFD1OffsetPointer) {\n            // console.log('******** IFD1Offset is empty, image thumb not found ********');\n            return {};\n        }\n        else if (IFD1OffsetPointer > dataView.byteLength) { // this should not happen\n            // console.log('******** IFD1Offset is outside the bounds of the DataView ********');\n            return {};\n        }\n        // console.log('*******  thumbnail IFD offset (IFD1) is: %s', IFD1OffsetPointer);\n\n        var thumbTags = readTags(dataView, tiffStart, tiffStart + IFD1OffsetPointer, IFD1Tags, bigEnd)\n\n        // EXIF 2.3 specification for JPEG format thumbnail\n\n        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n        // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n        // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n        // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n        // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n\n        if (thumbTags['Compression']) {\n            // console.log('Thumbnail image found!');\n\n            switch (thumbTags['Compression']) {\n                case 6:\n                    // console.log('Thumbnail image format is JPEG');\n                    if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {\n                    // extract the thumbnail\n                        var tOffset = tiffStart + thumbTags.JpegIFOffset;\n                        var tLength = thumbTags.JpegIFByteCount;\n                        thumbTags['blob'] = new Blob([new Uint8Array(dataView.buffer, tOffset, tLength)], {\n                            type: 'image/jpeg'\n                        });\n                    }\n                break;\n\n            case 1:\n                console.log(\"Thumbnail image format is TIFF, which is not implemented.\");\n                break;\n            default:\n                console.log(\"Unknown thumbnail image format '%s'\", thumbTags['Compression']);\n            }\n        }\n        else if (thumbTags['PhotometricInterpretation'] == 2) {\n            console.log(\"Thumbnail image format is RGB, which is not implemented.\");\n        }\n        return thumbTags;\n    }\n\n    function getStringFromDB(buffer, start, length) {\n        var outstr = \"\";\n        for (n = start; n < start+length; n++) {\n            outstr += String.fromCharCode(buffer.getUint8(n));\n        }\n        return outstr;\n    }\n\n    function readEXIFData(file, start) {\n        if (getStringFromDB(file, start, 4) != \"Exif\") {\n            if (debug) console.log(\"Not valid EXIF data! \" + getStringFromDB(file, start, 4));\n            return false;\n        }\n\n        var bigEnd,\n            tags, tag,\n            exifData, gpsData,\n            tiffOffset = start + 6;\n\n        // test for TIFF validity and endianness\n        if (file.getUint16(tiffOffset) == 0x4949) {\n            bigEnd = false;\n        } else if (file.getUint16(tiffOffset) == 0x4D4D) {\n            bigEnd = true;\n        } else {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x4949 or 0x4D4D)\");\n            return false;\n        }\n\n        if (file.getUint16(tiffOffset+2, !bigEnd) != 0x002A) {\n            if (debug) console.log(\"Not valid TIFF data! (no 0x002A)\");\n            return false;\n        }\n\n        var firstIFDOffset = file.getUint32(tiffOffset+4, !bigEnd);\n\n        if (firstIFDOffset < 0x00000008) {\n            if (debug) console.log(\"Not valid TIFF data! (First offset less than 8)\", file.getUint32(tiffOffset+4, !bigEnd));\n            return false;\n        }\n\n        tags = readTags(file, tiffOffset, tiffOffset + firstIFDOffset, TiffTags, bigEnd);\n\n        if (tags.ExifIFDPointer) {\n            exifData = readTags(file, tiffOffset, tiffOffset + tags.ExifIFDPointer, ExifTags, bigEnd);\n            for (tag in exifData) {\n                switch (tag) {\n                    case \"LightSource\" :\n                    case \"Flash\" :\n                    case \"MeteringMode\" :\n                    case \"ExposureProgram\" :\n                    case \"SensingMethod\" :\n                    case \"SceneCaptureType\" :\n                    case \"SceneType\" :\n                    case \"CustomRendered\" :\n                    case \"WhiteBalance\" :\n                    case \"GainControl\" :\n                    case \"Contrast\" :\n                    case \"Saturation\" :\n                    case \"Sharpness\" :\n                    case \"SubjectDistanceRange\" :\n                    case \"FileSource\" :\n                        exifData[tag] = StringValues[tag][exifData[tag]];\n                        break;\n\n                    case \"ExifVersion\" :\n                    case \"FlashpixVersion\" :\n                        exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);\n                        break;\n\n                    case \"ComponentsConfiguration\" :\n                        exifData[tag] =\n                            StringValues.Components[exifData[tag][0]] +\n                            StringValues.Components[exifData[tag][1]] +\n                            StringValues.Components[exifData[tag][2]] +\n                            StringValues.Components[exifData[tag][3]];\n                        break;\n                }\n                tags[tag] = exifData[tag];\n            }\n        }\n\n        if (tags.GPSInfoIFDPointer) {\n            gpsData = readTags(file, tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, GPSTags, bigEnd);\n            for (tag in gpsData) {\n                switch (tag) {\n                    case \"GPSVersionID\" :\n                        gpsData[tag] = gpsData[tag][0] +\n                            \".\" + gpsData[tag][1] +\n                            \".\" + gpsData[tag][2] +\n                            \".\" + gpsData[tag][3];\n                        break;\n                }\n                tags[tag] = gpsData[tag];\n            }\n        }\n\n        // extract thumbnail\n        tags['thumbnail'] = readThumbnailImage(file, tiffOffset, firstIFDOffset, bigEnd);\n\n        return tags;\n    }\n\n   function findXMPinJPEG(file) {\n\n        if (!('DOMParser' in self)) {\n            // console.warn('XML parsing not supported without DOMParser');\n            return;\n        }\n        var dataView = new DataView(file);\n\n        if (debug) console.log(\"Got file of length \" + file.byteLength);\n        if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {\n           if (debug) console.log(\"Not a valid JPEG\");\n           return false; // not a valid jpeg\n        }\n\n        var offset = 2,\n            length = file.byteLength,\n            dom = new DOMParser();\n\n        while (offset < (length-4)) {\n            if (getStringFromDB(dataView, offset, 4) == \"http\") {\n                var startOffset = offset - 1;\n                var sectionLength = dataView.getUint16(offset - 2) - 1;\n                var xmpString = getStringFromDB(dataView, startOffset, sectionLength)\n                var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;\n                xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\n\n                var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10\n                //Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n                //Without these namespaces, XML is thought to be invalid by parsers\n                xmpString = xmpString.slice(0, indexOfXmp)\n                            + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\n                            + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\n                            + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\n                            + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\n                            + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\n                            + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\n                            + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\n                            + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\n                            + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\n                            + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\n                            + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\n                            + xmpString.slice(indexOfXmp)\n\n                var domDocument = dom.parseFromString( xmpString, 'text/xml' );\n                return xml2Object(domDocument);\n            } else{\n             offset++;\n            }\n        }\n    }\n\n    function xml2json(xml) {\n        var json = {};\n      \n        if (xml.nodeType == 1) { // element node\n          if (xml.attributes.length > 0) {\n            json['@attributes'] = {};\n            for (var j = 0; j < xml.attributes.length; j++) {\n              var attribute = xml.attributes.item(j);\n              json['@attributes'][attribute.nodeName] = attribute.nodeValue;\n            }\n          }\n        } else if (xml.nodeType == 3) { // text node\n          return xml.nodeValue;\n        }\n      \n        // deal with children\n        if (xml.hasChildNodes()) {\n          for(var i = 0; i < xml.childNodes.length; i++) {\n            var child = xml.childNodes.item(i);\n            var nodeName = child.nodeName;\n            if (json[nodeName] == null) {\n              json[nodeName] = xml2json(child);\n            } else {\n              if (json[nodeName].push == null) {\n                var old = json[nodeName];\n                json[nodeName] = [];\n                json[nodeName].push(old);\n              }\n              json[nodeName].push(xml2json(child));\n            }\n          }\n        }\n        \n        return json;\n    }\n\n    function xml2Object(xml) {\n        try {\n            var obj = {};\n            if (xml.children.length > 0) {\n              for (var i = 0; i < xml.children.length; i++) {\n                var item = xml.children.item(i);\n                var attributes = item.attributes;\n                for(var idx in attributes) {\n                    var itemAtt = attributes[idx];\n                    var dataKey = itemAtt.nodeName;\n                    var dataValue = itemAtt.nodeValue;\n\n                    if(dataKey !== undefined) {\n                        obj[dataKey] = dataValue;\n                    }\n                }\n                var nodeName = item.nodeName;\n\n                if (typeof (obj[nodeName]) == \"undefined\") {\n                  obj[nodeName] = xml2json(item);\n                } else {\n                  if (typeof (obj[nodeName].push) == \"undefined\") {\n                    var old = obj[nodeName];\n\n                    obj[nodeName] = [];\n                    obj[nodeName].push(old);\n                  }\n                  obj[nodeName].push(xml2json(item));\n                }\n              }\n            } else {\n              obj = xml.textContent;\n            }\n            return obj;\n          } catch (e) {\n              console.log(e.message);\n          }\n    }\n\n    EXIF.enableXmp = function() {\n        EXIF.isXmpEnabled = true;\n    }\n\n    EXIF.disableXmp = function() {\n        EXIF.isXmpEnabled = false;\n    }\n\n    EXIF.getData = function(img, callback) {\n        if (((self.Image && img instanceof self.Image)\n            || (self.HTMLImageElement && img instanceof self.HTMLImageElement))\n            && !img.complete)\n            return false;\n\n        if (!imageHasData(img)) {\n            getImageData(img, callback);\n        } else {\n            if (callback) {\n                callback.call(img);\n            }\n        }\n        return true;\n    }\n\n    EXIF.getTag = function(img, tag) {\n        if (!imageHasData(img)) return;\n        return img.exifdata[tag];\n    }\n    \n    EXIF.getIptcTag = function(img, tag) {\n        if (!imageHasData(img)) return;\n        return img.iptcdata[tag];\n    }\n\n    EXIF.getAllTags = function(img) {\n        if (!imageHasData(img)) return {};\n        var a,\n            data = img.exifdata,\n            tags = {};\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                tags[a] = data[a];\n            }\n        }\n        return tags;\n    }\n    \n    EXIF.getAllIptcTags = function(img) {\n        if (!imageHasData(img)) return {};\n        var a,\n            data = img.iptcdata,\n            tags = {};\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                tags[a] = data[a];\n            }\n        }\n        return tags;\n    }\n\n    EXIF.pretty = function(img) {\n        if (!imageHasData(img)) return \"\";\n        var a,\n            data = img.exifdata,\n            strPretty = \"\";\n        for (a in data) {\n            if (data.hasOwnProperty(a)) {\n                if (typeof data[a] == \"object\") {\n                    if (data[a] instanceof Number) {\n                        strPretty += a + \" : \" + data[a] + \" [\" + data[a].numerator + \"/\" + data[a].denominator + \"]\\r\\n\";\n                    } else {\n                        strPretty += a + \" : [\" + data[a].length + \" values]\\r\\n\";\n                    }\n                } else {\n                    strPretty += a + \" : \" + data[a] + \"\\r\\n\";\n                }\n            }\n        }\n        return strPretty;\n    }\n\n    EXIF.readFromBinaryFile = function(file) {\n        return findEXIFinJPEG(file);\n    }\n\n    if (typeof define === 'function' && define.amd) {\n        define('exif-js', [], function() {\n            return EXIF;\n        });\n    }\n}.call(this));\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}